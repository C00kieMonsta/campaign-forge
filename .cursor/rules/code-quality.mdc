---
description: "Code quality standards, testing practices, and refactoring guidelines"
globs:
  - "**/*.ts"
  - "**/*.tsx"
alwaysApply: true
---

# Code Quality & Testing Standards

## üéØ Simplicity First

**The Best Code is Code That's Easy to Understand**

### Avoid Over-Engineering

```typescript
// ‚ùå OVER-ENGINEERED
function createCustomHOCForDataFetching<T, K extends keyof T>(
  dataSource: T,
  transformers?: Array<(data: T[K]) => T[K]>,
  memoizationStrategy?: "aggressive" | "conservative" | "none"
) {
  // ... 50 lines of complex logic
}

// ‚úÖ SIMPLE - Just do what's needed
function fetchData(url: string): Promise<Data> {
  return fetch(url).then(r => r.json());
}
```

### Avoid Unnecessary Abstractions

```typescript
// ‚ùå UNNECESSARY ABSTRACTION
class DataFetcherFactory {
  static createFetcher(type: "api" | "database"): IFetcher {
    if (type === "api") return new APIFetcher();
    return new DatabaseFetcher();
  }
}

// ‚úÖ SIMPLE - Just call what you need
const data = await fetchFromAPI(url);
const data = await fetchFromDatabase(query);
```

### Rule of Thumb: Can You Explain It in One Sentence?

If your function/class needs more than one sentence to explain, it's probably doing too much.

```typescript
// ‚ùå Hard to explain
function processAndValidateAndNormalizeAndCacheData(data) { }

// ‚úÖ Easy to explain
function validateData(data) { }
function normalizeData(data) { }
function cacheData(data) { }
```

---

## General Principles

### DRY (Don't Repeat Yourself)

Extract repeated code into reusable functions/components after first duplication:

```typescript
// ‚ùå BAD - repeated logic in two components
function ProjectCard({ project }) {
  return (
    <div className="border rounded p-4 shadow-sm">
      <h3 className="font-bold">{project.name}</h3>
      <p className="text-gray-600">{project.description}</p>
    </div>
  );
}

function SchemaCard({ schema }) {
  return (
    <div className="border rounded p-4 shadow-sm">
      <h3 className="font-bold">{schema.name}</h3>
      <p className="text-gray-600">{schema.description}</p>
    </div>
  );
}

// ‚úÖ GOOD - extract to reusable component
function Card({ title, description }: { title: string; description: string }) {
  return (
    <div className="border rounded p-4 shadow-sm">
      <h3 className="font-bold">{title}</h3>
      <p className="text-gray-600">{description}</p>
    </div>
  );
}

function ProjectCard({ project }) {
  return <Card title={project.name} description={project.description} />;
}

function SchemaCard({ schema }) {
  return <Card title={schema.name} description={schema.description} />;
}
```

### Single Responsibility Principle

One file/function = one clear job:

```typescript
// ‚ùå BAD - multiple responsibilities
function ExtractionDashboard() {
  const [jobs, setJobs] = useState([]);
  const [filter, setFilter] = useState("");
  const [sortBy, setSortBy] = useState("date");

  // Fetching
  useEffect(() => {
    fetch("/api/jobs").then(r => r.json()).then(setJobs);
  }, []);

  // Filtering
  const filtered = jobs.filter(j => j.name.includes(filter));

  // Sorting
  const sorted = [...filtered].sort((a, b) => {
    if (sortBy === "date") return b.date - a.date;
    return a.status.localeCompare(b.status);
  });

  // Rendering
  return (
    <div>
      <input value={filter} onChange={e => setFilter(e.target.value)} />
      {sorted.map(job => <JobCard key={job.id} job={job} />)}
    </div>
  );
}

// ‚úÖ GOOD - separated concerns
function useJobs() {
  return useExtractionJobs(); // From Redux store
}

function useFilteredJobs(jobs: TExtractionJob[], filter: string) {
  return useMemo(
    () => jobs.filter(j => j.name.includes(filter)),
    [jobs, filter]
  );
}

function useSortedJobs(jobs: TExtractionJob[], sortBy: "date" | "status") {
  return useMemo(() => {
    return [...jobs].sort((a, b) => {
      if (sortBy === "date") return b.createdAt.getTime() - a.createdAt.getTime();
      return a.status.localeCompare(b.status);
    });
  }, [jobs, sortBy]);
}

function ExtractionDashboard() {
  const [filter, setFilter] = useState("");
  const [sortBy, setSortBy] = useState<"date" | "status">("date");

  const jobs = useJobs();
  const filtered = useFilteredJobs(jobs, filter);
  const sorted = useSortedJobs(filtered, sortBy);

  return (
    <div>
      <input value={filter} onChange={e => setFilter(e.target.value)} />
      {sorted.map(job => <JobCard key={job.id} job={job} />)}
    </div>
  );
}
```

### Guard Clauses

Use early returns to reduce nesting:

```typescript
// ‚ùå BAD - nested conditionals
function processExtractionJob(job: TExtractionJob | null, userId: string): string {
  if (job) {
    if (job.status === "completed") {
      if (job.initiatedBy === userId) {
        return `Job ${job.id} completed`;
      } else {
        return "Permission denied";
      }
    } else {
      return `Job ${job.id} is ${job.status}`;
    }
  } else {
    return "Job not found";
  }
}

// ‚úÖ GOOD - guard clauses
function processExtractionJob(job: TExtractionJob | null, userId: string): string {
  if (!job) return "Job not found";
  if (job.status !== "completed") return `Job ${job.id} is ${job.status}`;
  if (job.initiatedBy !== userId) return "Permission denied";
  
  return `Job ${job.id} completed`;
}
```

### Function Size

Keep functions small and focused:

**Target:** <50 lines per function, <5 parameters

```typescript
// ‚ùå BAD - too large, too many params
async function processAndUploadJobResults(
  jobId,
  results,
  projectId,
  organizationId,
  userId,
  uploadToS3,
  sendNotification,
  updateDatabase
) {
  // 100+ lines of mixed logic
}

// ‚úÖ GOOD - decomposed into smaller functions
async function processJobResults(jobId: string, results: TExtractionResult[]) {
  return results.map(result => validateAndNormalize(result));
}

async function uploadResults(jobId: string, results: TExtractionResult[]) {
  return Promise.all(results.map(r => s3.upload(jobId, r)));
}

async function finalizeJob(jobId: string, results: TExtractionResult[]) {
  await updateJobStatus(jobId, "completed");
  await sendCompletionNotification(jobId);
  return { jobId, resultCount: results.length };
}

// Orchestrate in caller
async function executeJobPipeline(jobId: string) {
  const results = await fetchJobResults(jobId);
  const processed = await processJobResults(jobId, results);
  const uploaded = await uploadResults(jobId, processed);
  return finalizeJob(jobId, processed);
}
```

## Comments & Documentation

### When to Comment

Comment **why**, not **what**:

```typescript
// ‚ùå BAD - stating the obvious
function formatDate(date: Date): string {
  // Get the year, month, and day
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  
  // Return formatted string
  return `${year}-${month}-${day}`;
}

// ‚úÖ GOOD - explain intent
function formatDate(date: Date): string {
  // ISO 8601 format required for API compatibility
  return date.toISOString().split('T')[0];
}

// ‚úÖ GOOD - complex logic needs explanation
const SCHEMA_CACHE_TTL_MS = 3600000; // 1 hour TTL for production performance

// Schemas change infrequently, so we cache aggressively
// to reduce redundant compilation overhead during high-volume extractions
export function getCachedSchema(schemaId: string): TExtractionSchema | null {
  const cached = cache.get(schemaId);
  if (!cached || isExpired(cached.timestamp)) return null;
  return cached.schema;
}
```

### Documentation for Public APIs

Use JSDoc for exported functions/types:

```typescript
// ‚úÖ GOOD - clear documentation
/**
 * Filters extraction jobs by project with optional status filter
 * 
 * @param jobs - Array of extraction jobs to filter
 * @param projectId - Project ID to filter by
 * @param status - Optional job status filter
 * @returns Filtered array of extraction jobs
 * 
 * @example
 * const active = filterJobsByProject(jobs, "proj-123", "in_progress");
 */
export function filterJobsByProject(
  jobs: TExtractionJob[],
  projectId: string,
  status?: TExtractionJobStatus
): TExtractionJob[] {
  return jobs.filter(job => 
    job.projectId === projectId &&
    (!status || job.status === status)
  );
}
```

## Testing

### Unit Tests

Test a single function/method in isolation:

```typescript
// ‚úÖ GOOD - focused unit test
describe('formatExtractionJobStatus', () => {
  it('should format pending status', () => {
    const result = formatExtractionJobStatus('pending');
    expect(result).toBe('Waiting to Start');
  });

  it('should format in_progress status', () => {
    const result = formatExtractionJobStatus('in_progress');
    expect(result).toBe('Currently Processing');
  });

  it('should handle unknown status', () => {
    const result = formatExtractionJobStatus('unknown' as any);
    expect(result).toBe('Unknown');
  });
});

// ‚ùå BAD - too broad
describe('extraction jobs', () => {
  it('should work', () => {
    const job = { status: 'pending' };
    const formatted = formatExtractionJobStatus(job.status);
    // What exactly are we testing?
    expect(formatted).toBeDefined();
  });
});
```

### Integration Tests

Test how multiple components work together:

```typescript
// ‚úÖ GOOD - integration test
describe('ExtractionJobService', () => {
  let service: ExtractionJobService;
  let repository: ExtractionJobRepository;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        ExtractionJobService,
        ExtractionJobRepository,
        { provide: PrismaClient, useValue: mockPrisma }
      ]
    }).compile();

    service = module.get(ExtractionJobService);
    repository = module.get(ExtractionJobRepository);
  });

  it('should create job and store in repository', async () => {
    const input: TStartExtractionJobRequest = {
      organizationId: 'org-1',
      schemaId: 'schema-1',
      dataLayerId: 'data-1',
      jobType: 'material_extraction'
    };

    const job = await service.createJob(input);

    expect(job.id).toBeDefined();
    expect(job.status).toBe(EXTRACTION_JOB_STATUSES.PENDING);
    
    // Verify persisted to repository
    const retrieved = await repository.getById(job.id);
    expect(retrieved).toEqual(job);
  });
});
```

### E2E Tests

Test complete user flows:

```typescript
// ‚úÖ GOOD - end-to-end test
describe('Extraction Job Flow (e2e)', () => {
  let app: INestApplication;
  let client: TypedSupabaseClient;

  beforeAll(async () => {
    const module = await Test.createTestingModule({
      imports: [AppModule]
    }).compile();

    app = module.createNestApplication();
    await app.init();
    
    client = app.get(SupabaseClient);
  });

  it('should create and process extraction job end-to-end', async () => {
    // 1. Create project
    const projectRes = await request(app.getHttpServer())
      .post('/projects')
      .send({ name: 'Test Project' });
    const projectId = projectRes.body.id;

    // 2. Start extraction job
    const jobRes = await request(app.getHttpServer())
      .post('/extraction/jobs')
      .send({
        projectId,
        schemaId: 'schema-1',
        dataLayerId: 'data-1'
      })
      .expect(201);
    const jobId = jobRes.body.id;

    // 3. Verify job is queued
    const job = await client
      .from('extraction_jobs')
      .select('*')
      .eq('id', jobId)
      .single();

    expect(job.data.status).toBe('pending');
  });
});
```

### Test Data Factories

Create reusable test data:

```typescript
// @packages/types/src/test-factories/extraction.ts
import { TExtractionJob, EXTRACTION_JOB_STATUSES } from "../entities";

export function createMockExtractionJob(
  overrides?: Partial<TExtractionJob>
): TExtractionJob {
  return {
    id: "job-" + Math.random().toString(36).slice(2, 9),
    organizationId: "org-1",
    projectId: "proj-1",
    schemaId: "schema-1",
    initiatedBy: "user-1",
    status: EXTRACTION_JOB_STATUSES.PENDING,
    jobType: "material_extraction",
    progressPercentage: 0,
    startedAt: null,
    completedAt: null,
    createdAt: new Date(),
    updatedAt: new Date(),
    ...overrides
  };
}

// Usage in tests
const job = createMockExtractionJob({ status: "completed" });
```

## Code Review Checklist

When reviewing code, check for:

### Functionality
- [ ] Does the code solve the stated problem?
- [ ] Are edge cases handled?
- [ ] Is error handling present?

### Quality
- [ ] Follows package structure guidelines?
- [ ] Uses types from @packages/types?
- [ ] No code duplication?
- [ ] Functions <50 lines?
- [ ] Single responsibility?

### Performance
- [ ] No N+1 queries?
- [ ] Proper memoization?
- [ ] No unnecessary re-renders (frontend)?
- [ ] Efficient database queries (backend)?

### Testing
- [ ] Unit tests for business logic?
- [ ] Integration tests for flows?
- [ ] Test coverage >70%?

### Security
- [ ] Proper input validation?
- [ ] SQL injection prevention (Prisma)?
- [ ] XSS prevention?
- [ ] Auth guards on protected endpoints?

### Maintainability
- [ ] Clear variable names?
- [ ] Comments explaining why, not what?
- [ ] Consistent code style?
- [ ] Proper error messages?

## Refactoring Patterns

### Extract Function

When a function does too much, extract a helper:

```typescript
// Before
function generateReport(jobs: TExtractionJob[]): string {
  return jobs
    .filter(j => j.status === "completed")
    .sort((a, b) => b.completedAt!.getTime() - a.completedAt!.getTime())
    .map(j => `${j.id}: ${j.progressPercentage}%`)
    .join("\n");
}

// After
function isCompleted(job: TExtractionJob): boolean {
  return job.status === EXTRACTION_JOB_STATUSES.COMPLETED;
}

function sortByCompletedDate(a: TExtractionJob, b: TExtractionJob): number {
  return b.completedAt!.getTime() - a.completedAt!.getTime();
}

function formatJobRow(job: TExtractionJob): string {
  return `${job.id}: ${job.progressPercentage}%`;
}

function generateReport(jobs: TExtractionJob[]): string {
  return jobs
    .filter(isCompleted)
    .sort(sortByCompletedDate)
    .map(formatJobRow)
    .join("\n");
}
```

### Extract Constant

When using magic strings/numbers, extract to constants:

```typescript
// Before
if (job.progressPercentage === 100 && Date.now() - job.completedAt > 86400000) {
  archive(job);
}

// After
const COMPLETION_THRESHOLD_PERCENT = 100;
const ARCHIVE_AFTER_DAYS = 1;
const MS_PER_DAY = 86400000;

if (
  job.progressPercentage === COMPLETION_THRESHOLD_PERCENT &&
  Date.now() - job.completedAt > ARCHIVE_AFTER_DAYS * MS_PER_DAY
) {
  archive(job);
}
```

### Extract Type

When similar types are repeated, extract to shared type:

```typescript
// Before
interface UserResponse {
  id: string;
  name: string;
  email: string;
}

interface ProjectOwnerResponse {
  id: string;
  name: string;
  email: string;
}

// After - in @packages/types
export interface IUser {
  id: string;
  name: string;
  email: string;
}

// Then reference in both places
interface UserResponse extends IUser {}
interface ProjectOwnerResponse extends IUser {}
```

## Performance Debugging

### Frontend Performance

Use React DevTools Profiler:

```typescript
// ‚úÖ GOOD - identify slow components
import { Profiler } from "react";

function onRenderCallback(id, phase, actualDuration) {
  console.log(JSON.stringify({
    component: id,
    phase,
    duration: actualDuration,
    timestamp: new Date().toISOString()
  }));
}

export function App() {
  return (
    <Profiler id="app" onRender={onRenderCallback}>
      <Dashboard />
    </Profiler>
  );
}
```

### Backend Performance

Use query logging to identify slow operations:

```typescript
// ‚úÖ GOOD - log slow queries
@Injectable()
export class QueryLogger {
  constructor(private logger: Logger) {}

  logQuery(query: string, duration: number) {
    if (duration > 100) { // Log queries >100ms
      this.logger.warn(JSON.stringify({
        level: "warn",
        type: "slowQuery",
        duration,
        query: query.substring(0, 200)
      }));
    }
  }
}
```

## Type Safety

### Avoid `any`

Never use `any` - use proper types or generics:

```typescript
// ‚ùå BAD
function process(data: any): any {
  return data.map(x => x.value);
}

// ‚úÖ GOOD - generic
function process<T extends { value: unknown }>(data: T[]): unknown[] {
  return data.map(x => x.value);
}

// ‚úÖ GOOD - proper types
function processJobs(jobs: TExtractionJob[]): string[] {
  return jobs.map(j => j.id);
}
```

### Use Utility Types

Leverage TypeScript utility types:

```typescript
// ‚úÖ GOOD - using utility types
type JobReadonly = Readonly<TExtractionJob>;
type PartialJob = Partial<TExtractionJob>;
type JobKeys = keyof TExtractionJob;

function updateJob(id: string, updates: Partial<TExtractionJob>) {
  // ...
}

// ‚ùå BAD - manual typing
function updateJob(id: string, updates: {
  status?: TExtractionJobStatus;
  progressPercentage?: number;
  errorMessage?: string;
  // ... have to list all optional fields
}) {
  // ...
}
```

## Deployment Checklist

Before deploying code:

- [ ] All tests passing
- [ ] No console.error or console.warn in production code
- [ ] No hardcoded credentials or API keys
- [ ] Environment variables documented
- [ ] Database migrations run successfully
- [ ] No breaking changes to API contracts
- [ ] Performance benchmarks met
- [ ] Security audit passed
- [ ] Backward compatibility maintained