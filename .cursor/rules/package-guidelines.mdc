---
description: "Detailed guidelines for maintaining quality within each package"
globs:
  - "packages/**/*.ts"
  - "packages/**/*.tsx"
alwaysApply: true
---

# Package-Specific Guidelines

## ğŸ¯ Simplicity Rule for All Packages

Each package should solve ONE problem clearly:

- `@packages/types` â†’ Define types (nothing else!)
- `@packages/utils` â†’ Provide helpers (not full systems!)
- `@packages/core-client` â†’ Manage state (not business logic!)
- `@packages/ui` â†’ Render components (not contain logic!)

### If a package is getting complex, ask:
- â“ Am I mixing concerns?
- â“ Should this be split into smaller pieces?
- â“ Is there a simpler way?

---

## @packages/types

**Purpose:** Single source of truth for all types. Define entities and contracts here.

### What Goes Here

- âœ… Entity types (TUser, TProject, TExtractionJob, etc.)
- âœ… DTOs and Zod schemas for API contracts
- âœ… Repository interface contracts
- âœ… Service interface contracts
- âœ… Redux store state shapes
- âœ… Constants (enums) shared across apps
- âŒ Helper functions (go to @packages/utils)
- âŒ UI components (go to @packages/ui)

### Structure

```
types/src/
â”œâ”€â”€ constants.ts           # EXTRACTION_JOB_STATUSES, ROLE_SLUGS, etc.
â”œâ”€â”€ entities/
â”‚   â”œâ”€â”€ user.ts           # TUser, TProfile, etc.
â”‚   â”œâ”€â”€ project.ts        # TProject, TProjectMember, etc.
â”‚   â”œâ”€â”€ extraction.ts     # TExtractionJob, TExtractionResult, etc.
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ dto/
â”‚   â”œâ”€â”€ auth.ts           # LoginRequest, RegisterRequest, etc.
â”‚   â”œâ”€â”€ projects.ts       # CreateProjectRequest, UpdateProjectRequest, etc.
â”‚   â”œâ”€â”€ extractions.ts    # StartExtractionJobRequest, etc.
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ repositories/
â”‚   â”œâ”€â”€ project.repository.ts      # IProjectRepository interface
â”‚   â”œâ”€â”€ extraction.repository.ts   # IExtractionJobRepository interface
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ auth.service.ts    # IAuthService interface
â”‚   â”œâ”€â”€ project.service.ts # IProjectService interface
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ store/
â”‚   â”œâ”€â”€ auth.state.ts      # AuthState shape
â”‚   â”œâ”€â”€ projects.state.ts  # ProjectsState shape
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ schemas/               # Complex nested schemas (if needed)
â””â”€â”€ index.ts              # Central export
```

### Zod Schema Naming Convention

- Schema name: `{Entity}{Purpose}Schema` â†’ `TSchema = z.infer<typeof Schema>`
- Example: `CreateProjectSchema` â†’ `TCreateProjectRequest`
- DTOs use full schema pattern: `ZodSchema + z.infer`

```typescript
// âœ… CORRECT pattern
export const CreateProjectSchema = z.object({
  name: z.string().min(1).max(100),
  organizationId: Uuid,
  description: z.string().optional()
});

export type TCreateProjectRequest = z.infer<typeof CreateProjectSchema>;

// In consumers:
import { CreateProjectSchema, TCreateProjectRequest } from "@packages/types";
```

### Type Exports

Always provide both schema and type:
```typescript
// âœ… CORRECT - export both
export { CreateProjectSchema };
export type { TCreateProjectRequest };

// In consumers - they choose what they need:
const validated = CreateProjectSchema.parse(data); // Runtime validation
const typedData: TCreateProjectRequest = {...};    // Type checking only
```

## @packages/utils

**Purpose:** Shared utilities, helpers, formatters, and constants used across apps.

### What Goes Here

- âœ… Helper functions (formatting, parsing, transformation)
- âœ… Validators and validation utilities
- âœ… Constants and enums (business logic constants)
- âœ… Date/time utilities
- âœ… String utilities (slugify, camelCase, etc.)
- âœ… Collection utilities (groupBy, sortBy, etc.)
- âŒ Types/interfaces (go to @packages/types)
- âŒ UI components (go to @packages/ui)
- âŒ Redux logic (go to @packages/core-client)

### File Organization

```
utils/src/
â”œâ”€â”€ constants.ts
â”œâ”€â”€ helpers/
â”‚   â”œâ”€â”€ date.ts       # formatDate, parseDate, getRelativeTime
â”‚   â”œâ”€â”€ string.ts     # slugify, camelCase, truncate
â”‚   â”œâ”€â”€ array.ts      # groupBy, sortBy, unique, etc.
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ formatters/
â”‚   â”œâ”€â”€ job.ts        # formatJobStatus, formatJobProgress
â”‚   â”œâ”€â”€ project.ts    # formatProjectStatus
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ validators/
â”‚   â”œâ”€â”€ email.ts      # validateEmail
â”‚   â”œâ”€â”€ uuid.ts       # validateUuid
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ errors/
â”‚   â”œâ”€â”€ custom-errors.ts  # AppError, ValidationError
â”‚   â””â”€â”€ index.ts
â””â”€â”€ index.ts         # Central export
```

### Helper Function Style

- **Pure functions** when possible (no side effects)
- **Descriptive names** that start with verb: `formatDate`, `parseJobType`, `isValidUuid`
- **Guard clauses** for input validation

```typescript
// âœ… CORRECT
export function formatJobStatus(status: TExtractionJobStatus): string {
  if (!status) return "Unknown";
  
  const statusLabels: Record<TExtractionJobStatus, string> = {
    pending: "Waiting to Start",
    in_progress: "Currently Processing",
    completed: "Finished"
  };
  
  return statusLabels[status];
}

// âŒ WRONG - ambiguous naming, no guard clause
function jobStatus(s) {
  return { pending: "Waiting", in_progress: "Processing", completed: "Done" }[s];
}
```

### Constants Pattern

```typescript
// âœ… CORRECT - named constants with type safety
export const EXTRACTION_JOB_STATUSES = {
  PENDING: "pending",
  IN_PROGRESS: "in_progress",
  COMPLETED: "completed",
  FAILED: "failed"
} as const;

export const EXTRACTION_JOB_STATUSES_VALUES = Object.values(
  EXTRACTION_JOB_STATUSES
) as const;

// In @packages/types, use in Zod:
export const ExtractionJobStatus = z.enum(EXTRACTION_JOB_STATUSES_VALUES);
```

## @packages/core-client

**Purpose:** Client-side state management and data access (Redux, hooks, repositories).

### What Goes Here

- âœ… Redux slices, actions, and selectors
- âœ… Custom hooks that manage client state or fetch data
- âœ… Repository classes that fetch from API and dispatch Redux
- âœ… Hooks for reading from Redux (useCollection, useAppData, etc.)
- âŒ UI components (go to @packages/ui)
- âŒ Business logic helpers (go to @packages/utils)
- âŒ Type definitions (go to @packages/types)

### File Organization

```
core-client/src/
â”œâ”€â”€ store/
â”‚   â”œâ”€â”€ slices/
â”‚   â”‚   â”œâ”€â”€ auth.slice.ts
â”‚   â”‚   â”œâ”€â”€ projects.slice.ts
â”‚   â”‚   â”œâ”€â”€ extraction.slice.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ selectors/
â”‚   â”‚   â”œâ”€â”€ auth.selectors.ts
â”‚   â”‚   â”œâ”€â”€ projects.selectors.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ middleware/           # Optional: thunks, listeners
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ index.ts              # Store configuration
â”‚   â””â”€â”€ types.ts              # RootState, AppDispatch types
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useCollection.ts      # Generic hook for reading collection from store
â”‚   â”œâ”€â”€ useAppDataOrchestrator.ts  # Orchestrate initial data loading
â”‚   â”œâ”€â”€ useEntity.ts          # Read single entity from store
â”‚   â”œâ”€â”€ useExtractionJobs.ts  # Specific hooks using useCollection
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ repositories/
â”‚   â”œâ”€â”€ base.repository.ts    # Base class with common API logic
â”‚   â”œâ”€â”€ project.repository.ts
â”‚   â”œâ”€â”€ extraction.repository.ts
â”‚   â””â”€â”€ index.ts
â””â”€â”€ index.ts                  # Central export
```

### Redux Slice Pattern

Keep slices focused on a single entity or concern:

```typescript
// âœ… CORRECT - single concern
const extractionJobsSlice = createSlice({
  name: 'extractionJobs',
  initialState: {
    items: [] as TExtractionJob[],
    loading: false,
    error: null
  },
  reducers: {
    setExtractionJobs: (state, action: PayloadAction<TExtractionJob[]>) => {
      state.items = action.payload;
    },
    updateExtractionJob: (state, action: PayloadAction<TExtractionJob>) => {
      const idx = state.items.findIndex(j => j.id === action.payload.id);
      if (idx >= 0) state.items[idx] = action.payload;
    }
  }
});

// âŒ WRONG - mixed concerns in one slice
const appSlice = createSlice({
  name: 'app',
  initialState: {
    jobs: [],
    projects: [],
    users: [],
    settings: {},
    notifications: []
    // ... too many concerns
  }
});
```

### Hook Pattern for Reading from Store

Use `createSelector` for memoization to prevent unnecessary re-renders:

```typescript
// âœ… CORRECT - uses selector pattern for memoization
import { createSelector } from '@reduxjs/toolkit';
import { RootState } from './store';

const selectExtractionJobs = (state: RootState) => state.entities.extractionJobs;

export const selectJobsByProject = createSelector(
  [selectExtractionJobs, (_: RootState, projectId: string) => projectId],
  (jobs, projectId) => jobs.filter(j => j.projectId === projectId)
);

export function useExtractionJobsForProject(projectId: string) {
  const jobs = useSelector((state: RootState) => selectJobsByProject(state, projectId));
  return jobs;
}

// âŒ WRONG - direct inline selector, causes re-renders
export function useExtractionJobsForProject(projectId: string) {
  return useSelector((state: RootState) =>
    state.entities.extractionJobs.filter(j => j.projectId === projectId)
  );
}
```

### Repository Pattern

```typescript
// âœ… CORRECT - repository handles API + Redux dispatch
export class ExtractionJobRepository {
  constructor(private dispatch: AppDispatch) {}

  async getByProject(projectId: string): Promise<TExtractionJob[]> {
    try {
      const response = await fetch(`/api/extraction/project/${projectId}/jobs`);
      if (!response.ok) throw new Error('Failed to fetch jobs');
      
      const jobs = await response.json();
      
      // Dispatch to store
      this.dispatch(setExtractionJobs(jobs));
      
      return jobs;
    } catch (error) {
      console.error(JSON.stringify({ 
        error: 'Failed to fetch extraction jobs',
        projectId,
        details: error
      }));
      throw error;
    }
  }

  async updateStatus(jobId: string, status: TExtractionJobStatus) {
    const response = await fetch(`/api/extraction/jobs/${jobId}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ status })
    });
    
    const updated = await response.json();
    
    // Dispatch individual job update
    this.dispatch(updateExtractionJob(updated));
    
    return updated;
  }
}
```

## @packages/ui

**Purpose:** Shared, reusable UI components based on Radix UI + Tailwind.

### What Goes Here

- âœ… UI components (Button, Card, Modal, etc.)
- âœ… Form components with form state management
- âœ… Layout components (Container, Grid, Stack, etc.)
- âœ… Custom hooks for UI state (useModal, useForm, etc.)
- âœ… Tailwind utilities and style exports
- âŒ Page-level components (live in apps)
- âŒ Application logic/business logic
- âŒ Redux integration (that's app-specific)

### File Organization

```
ui/src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â”œâ”€â”€ Button.tsx
â”‚   â”‚   â”œâ”€â”€ Card.tsx
â”‚   â”‚   â”œâ”€â”€ Modal.tsx
â”‚   â”‚   â”œâ”€â”€ Alert.tsx
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ form/
â”‚   â”‚   â”œâ”€â”€ FormField.tsx
â”‚   â”‚   â”œâ”€â”€ Select.tsx
â”‚   â”‚   â”œâ”€â”€ Input.tsx
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ layout/
â”‚   â”‚   â”œâ”€â”€ Container.tsx
â”‚   â”‚   â”œâ”€â”€ Grid.tsx
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useModal.ts
â”‚   â”œâ”€â”€ useFormState.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ styles/
â”‚   â”œâ”€â”€ globals.css         # Tailwind + custom utilities
â”‚   â””â”€â”€ theme.css           # Color/spacing variables
â””â”€â”€ index.ts               # Central export
```

### Component Pattern

Use **compound component pattern** for complex components:

```typescript
// âœ… CORRECT - compound component
export const Modal = ({ children, open, onOpenChange }: Props) => (
  <Dialog open={open} onOpenChange={onOpenChange}>
    {children}
  </Dialog>
);

Modal.Content = function ModalContent({ children }: { children: React.ReactNode }) {
  return <DialogContent>{children}</DialogContent>;
};

Modal.Header = function ModalHeader({ children }: { children: React.ReactNode }) {
  return <DialogHeader>{children}</DialogHeader>;
};

Modal.Footer = function ModalFooter({ children }: { children: React.ReactNode }) {
  return <DialogFooter>{children}</DialogFooter>;
};

// Usage:
<Modal open={isOpen} onOpenChange={setIsOpen}>
  <Modal.Header>Confirm Action</Modal.Header>
  <Modal.Content>Are you sure?</Modal.Content>
  <Modal.Footer>
    <Button onClick={() => setIsOpen(false)}>Cancel</Button>
    <Button onClick={handleConfirm}>Confirm</Button>
  </Modal.Footer>
</Modal>
```

### Props Pattern

```typescript
// âœ… CORRECT - clear, typed props
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: "primary" | "secondary" | "ghost";
  size?: "sm" | "md" | "lg";
  loading?: boolean;
  children: React.ReactNode;
}

export function Button({ 
  variant = "primary", 
  size = "md", 
  loading = false,
  children,
  ...props 
}: ButtonProps) {
  return (
    <button 
      className={cn(buttonVariants({ variant, size }))}
      disabled={loading || props.disabled}
      {...props}
    >
      {loading ? <Spinner /> : children}
    </button>
  );
}
```

### Styling Pattern

Use **`class-variance-authority`** + **`tailwind-merge`** for variants:

```typescript
// âœ… CORRECT - type-safe variants
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@packages/utils'; // or clsx/tailwind-merge

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md font-medium",
  {
    variants: {
      variant: {
        primary: "bg-blue-600 text-white hover:bg-blue-700",
        secondary: "bg-gray-200 text-gray-900 hover:bg-gray-300",
        ghost: "text-gray-700 hover:bg-gray-100"
      },
      size: {
        sm: "px-2 py-1 text-sm",
        md: "px-4 py-2 text-base",
        lg: "px-6 py-3 text-lg"
      }
    },
    defaultVariants: {
      variant: "primary",
      size: "md"
    }
  }
);

export type ButtonVariants = VariantProps<typeof buttonVariants>;
export { buttonVariants };
```

## Cross-Package Communication

### Dependency Flow (Respect This)

```
@packages/types (no dependencies)
    â†“
@packages/utils (depends on types)
    â†“
@packages/core-client (depends on types + utils)
    â†“
@packages/ui (depends on types + utils)
    â†“
@apps/frontend, @apps/backend (depend on all)
```

### Never Create Circular Dependencies

âŒ BAD:
```typescript
// @packages/types imports from @packages/utils
import { formatDate } from "@packages/utils";
export type SomeType = { date: ReturnType<typeof formatDate> };

// @packages/utils imports from @packages/types
import { SomeType } from "@packages/types";
// Circular dependency!
```

âœ… GOOD:
```typescript
// @packages/types - just types
export type SomeType = { date: string };

// @packages/utils - helper functions
export function formatDate(d: Date): string { /* ... */ }
```

### Package Exports

Always provide a clear **index.ts** for each package:

```typescript
// âœ… CORRECT - @packages/types/src/index.ts
export * from "./entities";
export * from "./dto";
export * from "./repositories";
export * from "./store";
export { 
  EXTRACTION_JOB_STATUSES, 
  EXTRACTION_JOB_STATUSES_VALUES,
  // ... other constants
} from "./constants";
```

Then consumers import from the package:
```typescript
import { TExtractionJob, CreateProjectSchema } from "@packages/types";
// Not:
import { TExtractionJob } from "@packages/types/dist/entities";
```

## Performance Considerations

### Avoid Over-Fetching

- Fetch only what you need from API
- Use repository methods that return specific data shapes
- Don't fetch full entities if you only need a few fields

### Memoization in Selectors

Use `createSelector` in `@packages/core-client` to prevent unnecessary re-renders:

```typescript
// âœ… CORRECT - selector is memoized, only recomputes when input changes
const selectFilteredJobs = createSelector(
  [(state: RootState) => state.entities.extractionJobs, (_: RootState, filter: string) => filter],
  (jobs, filter) => jobs.filter(j => j.name.includes(filter))
);

// âŒ WRONG - inline filtering causes re-render on every selector call
const jobs = useSelector((state: RootState) => 
  state.entities.extractionJobs.filter(j => j.name.includes(filter))
);
```

### Tree-Shaking

Ensure unused code is removed in production:
- Use named exports (not default exports for large modules)
- Mark side-effect-free files in package.json: `"sideEffects": false`
- Keep utilities as pure functions